use wasabi_wasm::types::InferredInstructionType;
use wasabi_wasm::{
    BinaryOp, Code, Data, Element, Function, FunctionType, Global, GlobalOp, Idx, Label, LoadOp,
    Local, LocalOp, Memarg, Memory, Module, RefType, StoreOp, Table, UnaryOp, Val, ValType,
};

use super::typed_high_level_body_error::LowToHighError;
use super::typed_indexed_instr::{type_inference_index_function, TypedIndexedInstr};
use super::LowLevelBody;

pub type BodyInner = Vec<TypedHighLevelInstr>;

#[derive(Debug, Clone, Eq, PartialEq)]
pub struct Body(pub BodyInner);

impl Body {
    /// Equality check for instruction and type.
    /// Discarding equality for `funct_index`, `instr_index` or `instrumentation_instruction`
    #[must_use]
    pub fn instr_eq(&self, other: &Self) -> bool {
        let Self(body_self) = self;
        let Self(body_other) = other;
        body_self
            .iter()
            .zip(body_other)
            .all(|(i_s, i_o)| i_s.instr_eq(i_o))
    }
}

#[derive(Debug, Clone, Eq, PartialEq)]
pub struct TypedHighLevelInstr {
    pub funct_index: u32,
    pub instr_index: usize,
    pub type_: InferredInstructionType,
    pub instr: Instr,

    instrumentation_instruction: bool,
}

impl TypedHighLevelInstr {
    /// Equality check for instruction and type.
    /// Discarding equality for `funct_index`, `instr_index` or `instrumentation_instruction`
    #[must_use]
    pub fn instr_eq(&self, other: &Self) -> bool {
        let Self {
            funct_index: _,
            instr_index: _,
            type_,
            instr,
            instrumentation_instruction: _,
        } = self;
        let Self {
            funct_index: _funct_index_other,
            instr_index: _instr_index_other,
            type_: type_other,
            instr: instr_other,
            instrumentation_instruction: _instrumentation_instruction_other,
        } = other;
        type_ == type_other && instr == instr_other
    }
}

impl TypedHighLevelInstr {
    pub fn new_uninstrumented(
        funct_index: u32,
        instr_index: usize,
        type_: InferredInstructionType,
        instr: Instr,
    ) -> Self {
        Self {
            funct_index,
            instr_index,
            type_,
            instr,
            instrumentation_instruction: false,
        }
    }

    // This function makes it standard how we call to traps.
    // This 'trap calling convention' requires each trap to
    // ensure that the last two arguments are two i64 values;
    // indicating the function identifier & the instruction identifier
    pub fn to_trap_call(&self, target_function: &Idx<Function>) -> Vec<Self> {
        vec![
            // /*fidx*/ I64,
            self.instrument_with(Instr::Const(Val::I64(self.funct_index.into()))),
            // /*iidx*/ I64,
            self.instrument_with(Instr::Const(Val::I64(self.instr_index.try_into().unwrap()))),
            // Inject call to trap
            self.instrument_with(Instr::Call(*target_function)),
        ]
    }

    /// This method allows to assert that our target instruction
    /// does not originate from an instrumentation pass.
    pub fn instrument_with(&self, instr: Instr) -> Self {
        assert!(
            !self.instrumentation_instruction,
            "Should not instrument code that was generated by instrumentation platform!"
        );
        Self {
            funct_index: self.funct_index,
            instr_index: self.instr_index,
            instr,
            type_: InferredInstructionType::Unreachable, // We will not infer the type, nor is this ever relevant!

            instrumentation_instruction: true,
        }
    }

    pub fn place_original(&self, instr: Instr) -> Self {
        assert!(
            !self.instrumentation_instruction,
            "Should not handle target instruction as if it is an original instruction ...!"
        );
        Self {
            funct_index: self.funct_index,
            instr_index: self.instr_index,
            instr,
            type_: self.type_.clone(),

            instrumentation_instruction: self.instrumentation_instruction,
        }
    }

    pub fn place_untouched(&self, instr: Instr) -> Self {
        // Do not assert on instrumentation_instruction
        Self {
            funct_index: self.funct_index,
            instr_index: self.instr_index,
            instr,
            type_: self.type_.clone(),

            instrumentation_instruction: self.instrumentation_instruction,
        }
    }

    pub fn is_uninstrumented(&self) -> bool {
        !self.instrumentation_instruction
    }
}

/// Typed instructions with high-level body.
///
/// Equal to `wasabi_wasm::Instr` minus `Else` and `End` instruction
/// Which occur in `Block`, `Loop` and `If`
/// Cfr. [Control Instructions](https://webassembly.github.io/spec/core/syntax/instructions.html#syntax-instr-control)
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum Instr {
    Unreachable,
    Nop,

    Block(FunctionType, BodyInner),
    Loop(FunctionType, BodyInner),
    If(FunctionType, BodyInner, Option<BodyInner>),

    Br(Label),
    BrIf(Label),
    BrTable { table: Box<[Label]>, default: Label },

    Return,
    Call(Idx<Function>),
    CallIndirect(FunctionType, Idx<Table>),

    RefNull(RefType),
    RefIsNull,
    RefFunc(Idx<Function>),

    Drop,
    Select,
    TypedSelect(ValType),

    Local(LocalOp, Idx<Local>),
    Global(GlobalOp, Idx<Global>),

    TableGet(Idx<Table>),
    TableSet(Idx<Table>),
    TableSize(Idx<Table>),
    TableGrow(Idx<Table>),
    TableFill(Idx<Table>),
    TableCopy(Idx<Table>, Idx<Table>),
    TableInit(Idx<Table>, Idx<Element>),
    ElemDrop(Idx<Element>),

    Load(LoadOp, Memarg),
    Store(StoreOp, Memarg),

    MemorySize(Idx<Memory>),
    MemoryGrow(Idx<Memory>),
    MemoryFill,
    MemoryCopy,
    MemoryInit(Idx<Data>),
    DataDrop(Idx<Data>),

    Const(Val),
    Unary(UnaryOp),
    Binary(BinaryOp),
}

impl TryFrom<wasabi_wasm::Instr> for Instr {
    type Error = LowToHighError;

    fn try_from(value: wasabi_wasm::Instr) -> Result<Self, Self::Error> {
        Ok(match value {
            // Happy path
            wasabi_wasm::Instr::Unreachable => Instr::Unreachable,
            wasabi_wasm::Instr::Nop => Instr::Nop,
            wasabi_wasm::Instr::Br(v) => Instr::Br(v),
            wasabi_wasm::Instr::BrIf(v) => Instr::BrIf(v),
            wasabi_wasm::Instr::BrTable { table, default } => Instr::BrTable { table, default },
            wasabi_wasm::Instr::Return => Instr::Return,
            wasabi_wasm::Instr::Call(v) => Instr::Call(v),
            wasabi_wasm::Instr::CallIndirect(v1, v2) => Instr::CallIndirect(v1, v2),
            wasabi_wasm::Instr::RefNull(v) => Instr::RefNull(v),
            wasabi_wasm::Instr::RefIsNull => Instr::RefIsNull,
            wasabi_wasm::Instr::RefFunc(v) => Instr::RefFunc(v),
            wasabi_wasm::Instr::Drop => Instr::Drop,
            wasabi_wasm::Instr::Select => Instr::Select,
            wasabi_wasm::Instr::TypedSelect(v) => Instr::TypedSelect(v),
            wasabi_wasm::Instr::Local(v1, v2) => Instr::Local(v1, v2),
            wasabi_wasm::Instr::Global(v1, v2) => Instr::Global(v1, v2),
            wasabi_wasm::Instr::TableGet(v) => Instr::TableGet(v),
            wasabi_wasm::Instr::TableSet(v) => Instr::TableSet(v),
            wasabi_wasm::Instr::TableSize(v) => Instr::TableSize(v),
            wasabi_wasm::Instr::TableGrow(v) => Instr::TableGrow(v),
            wasabi_wasm::Instr::TableFill(v) => Instr::TableFill(v),
            wasabi_wasm::Instr::TableCopy(v1, v2) => Instr::TableCopy(v1, v2),
            wasabi_wasm::Instr::TableInit(v1, v2) => Instr::TableInit(v1, v2),
            wasabi_wasm::Instr::ElemDrop(v) => Instr::ElemDrop(v),
            wasabi_wasm::Instr::Load(v1, v2) => Instr::Load(v1, v2),
            wasabi_wasm::Instr::Store(v1, v2) => Instr::Store(v1, v2),
            wasabi_wasm::Instr::MemorySize(v) => Instr::MemorySize(v),
            wasabi_wasm::Instr::MemoryGrow(v) => Instr::MemoryGrow(v),
            wasabi_wasm::Instr::MemoryFill => Instr::MemoryFill,
            wasabi_wasm::Instr::MemoryCopy => Instr::MemoryCopy,
            wasabi_wasm::Instr::MemoryInit(v) => Instr::MemoryInit(v),
            wasabi_wasm::Instr::DataDrop(v) => Instr::DataDrop(v),
            wasabi_wasm::Instr::Const(v) => Instr::Const(v),
            wasabi_wasm::Instr::Unary(v) => Instr::Unary(v),
            wasabi_wasm::Instr::Binary(v) => Instr::Binary(v),
            // Sad path
            wasabi_wasm::Instr::Block(_)
            | wasabi_wasm::Instr::Loop(_)
            | wasabi_wasm::Instr::If(_)
            | wasabi_wasm::Instr::Else
            | wasabi_wasm::Instr::End => return Err(LowToHighError::TrivialCastAttempt),
        })
    }
}

impl Instr {
    #[must_use]
    pub fn if_then(type_: FunctionType, then: BodyInner) -> Self {
        Instr::If(type_, then, None)
    }

    #[must_use]
    pub fn if_then_else(type_: FunctionType, then: BodyInner, else_: BodyInner) -> Self {
        Instr::If(type_, then, Some(else_))
    }
}

impl TryFrom<(&Module, &Function, &Code, &Idx<Function>)> for Body {
    type Error = LowToHighError;

    fn try_from(
        module_function_code: (&Module, &Function, &Code, &Idx<Function>),
    ) -> Result<Self, Self::Error> {
        let (module, function, code, original_idx) = module_function_code;
        let indexed_typed_body =
            type_inference_index_function(function, code, module, original_idx)
                .map_err(|e| LowToHighError::TypeInference { type_error: e })?;

        enum EnteredType {
            Block,
            Loop,
            IfStart,
            IfThenElse(BodyInner),
        }

        struct Entered {
            entered_type: EnteredType,
            funct_index: u32,
            index: usize,
            type_: FunctionType,
        }

        let [instructions @ .., TypedIndexedInstr {
            funct_index: _,
            instr_index: _,
            type_: _,
            instr: wasabi_wasm::Instr::End,
        }] = &indexed_typed_body[..]
        else {
            return Err(LowToHighError::BodyNonEndTermination);
        };

        let mut entered_stack: Vec<Entered> = Vec::new();
        let mut body_stack: Vec<BodyInner> = Vec::new();
        let mut current_body: BodyInner = Vec::new();

        for TypedIndexedInstr {
            funct_index,
            instr_index: index,
            type_,
            instr,
        } in instructions
        {
            match instr {
                wasabi_wasm::Instr::Block(type_) => {
                    entered_stack.push(Entered {
                        funct_index: *funct_index,
                        index: *index,
                        type_: *type_,
                        entered_type: EnteredType::Block,
                    });
                    body_stack.push(current_body.clone());
                    current_body = Vec::new();
                }
                wasabi_wasm::Instr::Loop(type_) => {
                    entered_stack.push(Entered {
                        funct_index: *funct_index,
                        index: *index,
                        type_: *type_,
                        entered_type: EnteredType::Loop,
                    });
                    body_stack.push(current_body.clone());
                    current_body = Vec::new();
                }
                wasabi_wasm::Instr::If(type_) => {
                    entered_stack.push(Entered {
                        funct_index: *funct_index,
                        index: *index,
                        type_: *type_,
                        entered_type: EnteredType::IfStart,
                    });
                    body_stack.push(current_body.clone());
                    current_body = Vec::new();
                }
                wasabi_wasm::Instr::Else => match entered_stack.pop() {
                    Some(Entered {
                        funct_index,
                        index,
                        type_,
                        entered_type: EnteredType::IfStart,
                    }) => {
                        let then_body = current_body.clone();
                        entered_stack.push(Entered {
                            funct_index,
                            index,
                            type_,
                            entered_type: EnteredType::IfThenElse(then_body),
                        });
                        current_body = Vec::new();
                    }
                    _ => return Err(LowToHighError::IfDidNotPrecedeElse),
                },
                wasabi_wasm::Instr::End => {
                    let ended_body = current_body.clone();
                    let (begin_idx, instruction) =
                        match entered_stack.pop().ok_or(LowToHighError::ExcessiveEnd)? {
                            Entered {
                                funct_index: _,
                                index,
                                type_,
                                entered_type: EnteredType::Block,
                            } => (index, Instr::Block(type_, ended_body)),
                            Entered {
                                funct_index: _,
                                index,
                                type_,
                                entered_type: EnteredType::Loop,
                            } => (index, Instr::Loop(type_, ended_body)),
                            Entered {
                                funct_index: _,
                                index,
                                type_,
                                entered_type: EnteredType::IfStart,
                            } => (index, Instr::if_then(type_, ended_body)),
                            Entered {
                                funct_index: _,
                                index,
                                type_,
                                entered_type: EnteredType::IfThenElse(then_body),
                            } => (index, Instr::if_then_else(type_, then_body, ended_body)),
                        };
                    current_body = body_stack.pop().ok_or(LowToHighError::EndWithoutParent)?;
                    current_body.push(TypedHighLevelInstr::new_uninstrumented(
                        *funct_index,
                        begin_idx, // prefer the begin-index over the end-index!
                        type_.clone(),
                        instruction,
                    ));
                }
                instruction => current_body.push(TypedHighLevelInstr::new_uninstrumented(
                    *funct_index,
                    *index,
                    type_.clone(),
                    instruction.clone().try_into()?,
                )),
            };
        }

        assert!(entered_stack.is_empty());
        assert!(body_stack.is_empty());
        Ok(Body(current_body))
    }
}

impl From<Body> for LowLevelBody {
    fn from(typed_high_level_body: Body) -> Self {
        let Body(body_inner) = typed_high_level_body;
        let mut low_level_body = from_recurse(body_inner);
        low_level_body.push(wasabi_wasm::Instr::End);
        Self(low_level_body)
    }
}

fn from_recurse(instructions: BodyInner) -> Vec<wasabi_wasm::Instr> {
    let mut result = Vec::with_capacity(instructions.len());
    for TypedHighLevelInstr { instr, .. } in instructions {
        match instr {
            // interesting
            Instr::Block(type_, body_) => {
                result.push(wasabi_wasm::Instr::Block(type_));
                result.extend(from_recurse(body_));
                result.push(wasabi_wasm::Instr::End);
            }
            Instr::Loop(type_, body_) => {
                result.push(wasabi_wasm::Instr::Loop(type_));
                result.extend(from_recurse(body_));
                result.push(wasabi_wasm::Instr::End);
            }
            Instr::If(type_, then, Some(else_)) => {
                result.push(wasabi_wasm::Instr::If(type_));
                result.extend(from_recurse(then));
                result.push(wasabi_wasm::Instr::Else);
                result.extend(from_recurse(else_));
                result.push(wasabi_wasm::Instr::End);
            }
            Instr::If(type_, then, None) => {
                result.push(wasabi_wasm::Instr::If(type_));
                result.extend(from_recurse(then));
                result.push(wasabi_wasm::Instr::End);
            }

            // rest is not interesting, just push in result
            Instr::Unreachable => result.push(wasabi_wasm::Instr::Unreachable),
            Instr::Nop => result.push(wasabi_wasm::Instr::Nop),
            Instr::Br(v) => result.push(wasabi_wasm::Instr::Br(v)),
            Instr::BrIf(v) => result.push(wasabi_wasm::Instr::BrIf(v)),
            Instr::BrTable { table, default } => {
                result.push(wasabi_wasm::Instr::BrTable { table, default });
            }
            Instr::Return => result.push(wasabi_wasm::Instr::Return),
            Instr::Call(v) => result.push(wasabi_wasm::Instr::Call(v)),
            Instr::CallIndirect(v1, v2) => {
                result.push(wasabi_wasm::Instr::CallIndirect(v1, v2));
            }
            Instr::RefNull(v) => result.push(wasabi_wasm::Instr::RefNull(v)),
            Instr::RefIsNull => result.push(wasabi_wasm::Instr::RefIsNull),
            Instr::RefFunc(v) => result.push(wasabi_wasm::Instr::RefFunc(v)),
            Instr::Drop => result.push(wasabi_wasm::Instr::Drop),
            Instr::Select => result.push(wasabi_wasm::Instr::Select),
            Instr::TypedSelect(v) => result.push(wasabi_wasm::Instr::TypedSelect(v)),
            Instr::Local(v1, v2) => result.push(wasabi_wasm::Instr::Local(v1, v2)),
            Instr::Global(v1, v2) => result.push(wasabi_wasm::Instr::Global(v1, v2)),
            Instr::TableGet(v) => result.push(wasabi_wasm::Instr::TableGet(v)),
            Instr::TableSet(v) => result.push(wasabi_wasm::Instr::TableSet(v)),
            Instr::TableSize(v) => result.push(wasabi_wasm::Instr::TableSize(v)),
            Instr::TableGrow(v) => result.push(wasabi_wasm::Instr::TableGrow(v)),
            Instr::TableFill(v) => result.push(wasabi_wasm::Instr::TableFill(v)),
            Instr::TableCopy(v1, v2) => result.push(wasabi_wasm::Instr::TableCopy(v1, v2)),
            Instr::TableInit(v1, v2) => result.push(wasabi_wasm::Instr::TableInit(v1, v2)),
            Instr::ElemDrop(v) => result.push(wasabi_wasm::Instr::ElemDrop(v)),
            Instr::Load(v1, v2) => result.push(wasabi_wasm::Instr::Load(v1, v2)),
            Instr::Store(v1, v2) => result.push(wasabi_wasm::Instr::Store(v1, v2)),
            Instr::MemorySize(v) => result.push(wasabi_wasm::Instr::MemorySize(v)),
            Instr::MemoryGrow(v) => result.push(wasabi_wasm::Instr::MemoryGrow(v)),
            Instr::MemoryFill => result.push(wasabi_wasm::Instr::MemoryFill),
            Instr::MemoryCopy => result.push(wasabi_wasm::Instr::MemoryCopy),
            Instr::MemoryInit(v) => result.push(wasabi_wasm::Instr::MemoryInit(v)),
            Instr::DataDrop(v) => result.push(wasabi_wasm::Instr::DataDrop(v)),
            Instr::Const(v) => result.push(wasabi_wasm::Instr::Const(v)),
            Instr::Unary(v) => result.push(wasabi_wasm::Instr::Unary(v)),
            Instr::Binary(v) => result.push(wasabi_wasm::Instr::Binary(v)),
        }
    }
    result
}

#[cfg(test)]
mod tests {
    use super::Body;
    use wasabi_wasm::{
        types::InferredInstructionType, Code, Function, FunctionType, Idx, Module, ValType,
    };

    const EVEN_ODD_PROGRAM: &str = r#"
    (module
      (func $even (export "even") (param $n i32) (result i32)
        (if (result i32) (i32.eq (local.get $n) (i32.const 0))
          (then (i32.const 1))
          (else (call $odd (i32.sub (local.get $n) (i32.const 1))))
        )
      )

      (func $odd (export "odd") (param $n i32) (result i32)
        (if (result i32) (i32.eq (local.get $n) (i32.const 0))
          (then (i32.const 0))
          (else (call $even (i32.sub (local.get $n) (i32.const 1))))
        )
      )
    )
    "#;

    #[test]
    fn test_if_then_else() {
        let if_then_else_program = wat::parse_str(EVEN_ODD_PROGRAM).unwrap();
        let (module, _, _) = Module::from_bytes(&if_then_else_program).unwrap();

        let get_high_level_body = |module: &Module, index: usize| {
            let (func, code): (&Function, &Code) = (
                module.function(index.into()),
                module.function(index.into()).code().unwrap(),
            );
            let f_idx = &Idx::from(index);
            Body::try_from((module, func, code, f_idx)).unwrap()
        };

        // Expected type of the first statement for both functions even and odd
        let expected_type = FunctionType::new(&[], &[ValType::I32]);
        let expected_type = InferredInstructionType::Reachable(expected_type);

        let body_even = get_high_level_body(&module, 0);
        let Body(body_even) = body_even;
        assert_eq!(expected_type, body_even.first().unwrap().type_);

        let body_odd = get_high_level_body(&module, 1);
        let Body(body_odd) = body_odd;
        assert_eq!(expected_type, body_odd.first().unwrap().type_);
    }
}
