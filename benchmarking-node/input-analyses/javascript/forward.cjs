/* User-facing API for dynamic analyses. */
Wasabi.analysis = {
    start(location) { /* (location, "start") */ },
    nop(location) { /* (location, "nop") */ },
    unreachable(location) { /* (location, "unreachable") */ },
    if_(location, condition) { /* (location, "if, condition =", condition) */ },
    br(location, target) { /* (location, "br, to label", target.label, "(==", target.location, ")") */ },
    br_if(location, conditionalTarget, condition) { /* (location, "br_if, (conditionally) to label", conditionalTarget.label, "(==", conditionalTarget.location, "), condition =", condition) */ },
    br_table(location, table, defaultTarget, tableIdx) { /* (location, "br_table, table =", table, ", default target =", defaultTarget, ", table index =", tableIdx) */ },
    begin(location, type) { /* (location, "begin", type) */ },
    end(location, type, beginLocation, ifLocation) { /* (location, "end", type, "(begin @", beginLocation, ", if begin @", ifLocation, ")") */ },
    drop(location, value) { /* (location, "drop, value =", value) */ },
    select(location, cond, first, second) { /* (location, "select, condition =", cond, "first =", first, "second =", second) */ },
    call_pre(location, targetFunc, args, indirectTableIdx) { /* (location, (indirectTableIdx === undefined ? "direct" : "indirect"), "call", "to func #", targetFunc, "args =", args) */ },
    call_post(location, values) { /* (location, "call result =", values) */ },
    return_(location, values) { /* (location, (location.instr === -1) ? "implicit" : "explicit", "return, values = ", values) */ },
    const_(location, op, value) { /* (location, op, "value =", value) */ },
    unary(location, op, input, result) { /* (location, op, "input =", input, "result =", result) */ },
    binary(location, op, first, second, result) { /* (location, op, "first =", first, " second =", second, "result =", result) */ },
    load(location, op, memarg, value) { /* (location, op, "value =", value, "from =", memarg) */ },
    store(location, op, memarg, value) { /* (location, op, "value =", value, "to =", memarg) */ },
    memory_size(location, currentSizePages) { /* (location, "memory_size, size (in pages) =", currentSizePages) */ },
    memory_grow(location, byPages, previousSizePages) { /* (location, "memory_grow, delta (in pages) =", byPages, "previous size (in pages) =", previousSizePages) */ },
    local(location, op, localIndex, value) { /* (location, op, "local #", localIndex, "value =", value) */ },
    global(location, op, globalIndex, value) { /* (location, op, "global #", globalIndex, "value =", value) */ },
};
